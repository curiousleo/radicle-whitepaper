\section{Sample Programs and Chains}
\label{s:examples}

In this section, we develop a better sense for the language and its
applications by considering sample programs.

\subsection{Self-amending key-value store}

In Section \ref{s:language}, we defined a simple key-value store language. It
was not, however, an \emph{amendable} one---once defined, it was impossible to
change the semantics of the running system. For short-lived chains with a narrow
purpose, this might be satisfactory. For long-lived chains, the participants
ideas on the purpose of the chain may morph over time. Forking to a new chain is
an option, but this is not ideal for two reasons:
\begin{itemize}
  \item Consensus on the purpose and semantics of the new chain must be achieved
    ``off chain''.
  \item Participants must agree on the process and logistics of migrating to a
    new chain, how to decide from which block this takes place, etc.
\end{itemize}
In radicle this can all take place on-chain, by updating the eval function.
\input{out/kv1.rad-tex}
Note that in this case, the new evaluation function that is instantiated as a
result of a an \texttt{update} command, is the result of evaluating an
expression with the original \texttt{eval} function, because of the hyperstatic
environments. Thus, in this case, no tower of interpreters is formed. Instead,
we are swapping out one eval for another.

\subsection{Currency}

TODO: discuss how we can insure that only bob can submit the command
\texttt{(transfer "bob" x n)}.

In this section we define a currency. This example demonstrates both higher
order functions and data-hiding. Indeed the \texttt{create-currency} function
defines all the state needed for the operation of the currency but then only
returns the relevant evaluation function, making the internals of the currency
unavailable to the caller. Furthermore, by returning a potential evaluation
function (rather than setting it directly), this function may be used as a
sub-behaviour of a more featurefull RSM.
\input{out/currency.rad-tex}
After loading this code, we can imagine the following \rad{} session:
\bigskip
\begin{Verbatim}[fontsize=\small]
> (write-ref eval-ref (create-currency))
=> ()
> (new-account "alice")
=> :ok
> (new-account "bob")
=> :ok
> (transfer "alice" "bob" 3)
=> :ok
> (balance "alice")
=> 7
\end{Verbatim}

\subsection{Updatable state-machine}

Some chains will operate simple state machines that are best described as a
radicle function \texttt{transition} which takes the current state and an input
and returns a new state. For example we might want to maintain a number:
\begin{lstlisting}
(define initial-state 0)
(define transition
  (lambda (current-state input)
    (+ current-state input)))
\end{lstlisting}
Given such a function, and an \texttt{initial-state}, it's simple to turn
\rad{} into the specified state-machine:
\begin{lstlisting}
(define state (ref initial-state))
(define new-eval
  (lambda (e)
    (write-ref state
               (transition (read-ref state) e))))

(write-ref eval-ref new-eval)
\end{lstlisting}

However, in so doing we have lost the ability to modify \texttt{transition} in
any way.

So as to allow for such modifications, we define a state-machine which runs other
state-machines while also accepting meta-commands for operations such as voting
for a new transition function.

Inputs are partitioned into \emph{basic inputs}:
\[
\mathtt{(basic} \ i),
\]
where $i$ are values accepted by \texttt{transition}, and \emph{meta-inputs}:
\[
\mathtt{(meta} \ c),
\]
where the $c$ are messages participants use to coordinate in choosing a new
transition function. All basic-inputs are handled by \texttt{transition}
to update the current state. Examples of meta-inputs are:
\begin{align*}
  (\text{\texttt{new-transition-function}} \ f \ u)\\
  (\text{\texttt{vote-agree}} \ uid \ s)\\
  (\text{\texttt{vote-disagree}} \ uid \ s)
\end{align*}
where
\begin{itemize}
\item $f$ is a new transition function,
\item $u$ is a function used to upgrade the state, if it now has a new format,
\item $uid$ is a user identifier,
\item $s$ is a cryptographic signature to validate the vote.
\end{itemize}
The resulting function \texttt{run-state-machine} could also take in other
parameters, for example to instantiate different voting processes, etc. In fact,
one could conceivably include a command for upgrading the whole function which
handles meta-level commands.

Using this higher-order function we can now demonstrate several interesting
examples of chains:
\begin{itemize}
\item Issue chain, only person who opened issue and maintainers can close, only
  maintainers can update the transition function.
\item Ultimate example: chain managing a repo. The set of maintainers is
  maintained in a config file in master branch. only maintainers can accept PRs
  to master. Only maintainers can vote on new transition functions. This means
  that the function $m$ reads not only from the vote state $\bar S$ but also the
  basic state $S$ (i.e. the source code under version control).
\end{itemize}
